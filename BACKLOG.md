
## Backlog

### Команда `delete` не принимает имена selection
- **Описание:** `delete` работает только с объектами, но не с selections. Это общая проблема — многие команды, которые должны принимать и объекты, и selections, принимают только объекты.
- **Решение:** Нужна единая абстракция для резолва имён (object OR selection) во всех командах, которые работают с "именованными сущностями". Возможно, trait `Resolvable` или функция `resolve_name_or_selection()`.
- **Приоритет:** средний
- **Дата:** 2026-02-18

### Автокомплит локальных файловых путей
- **Описание:** Автокомплит путей работает только с префиксом `./`. Хочется чтобы `load 1<Tab>` предлагал файлы, начинающиеся на `1`, из текущей директории без явного `./`.
- **Решение:** В логике Tab-completion для аргументов файловых команд (load, save, etc.) добавить fallback на автокомплит из cwd, даже если путь не начинается с `./` или `/`.
- **Дополнение:** Автокомплит должен показывать относительные пути (от cwd), а не абсолютные. Сейчас показывает полные пути типа `/Users/pavel/SynologyDrive/DEV/.../file.pdb` — нечитаемо, самое важное в конце.
- **Приоритет:** средний
- **Дата:** 2026-02-18

### Рефакторинг команды `set`
- **Описание:** Функция `set` стала огромной и монструозной — каждая новая настройка раздувает её ещё больше. Нужна нормальная архитектура.
- **Решение:** Декларативный подход — каждый setting регистрирует свой handler/validator/side-effect. `set` становится диспетчером, а не God-функцией. Возможные варианты: trait-based dispatch, registry pattern, или derive-макрос для автогенерации обработчиков из definitions.
- **Приоритет:** высокий (блокирует масштабирование настроек)
- **Дата:** 2026-02-18

### Автокомплит для команды `set`
- **Описание:** 807 настроек невозможно запомнить. Нужен Tab-completion для имён settings после `set `.
- **Решение:** Генерировать список имён settings из definitions и подключить к Tab-completion. Бонус: автокомплит значений для enum-like настроек (shading_mode → classic/skripkin).
- **Приоритет:** высокий
- **Дата:** 2026-02-18

### Парсинг Float3/List значений сломан при comma-separated аргументах
- **Описание:** `set silhouette_color, [1.0, 1.0, 1.0]` падает — парсер аргументов разбивает по запятым до того, как parse_list увидит полное выражение в скобках `[...]`. Та же проблема с `set silhouette_color, 1.0, 1.0, 1.0` — парсер видит `1.0` как одно float-значение, а не float3.
- **Корень проблемы:** `parse_arguments` в parser.rs разделяет по запятым без учёта вложенности квадратных скобок `[...]`. Запятая внутри `[1.0, 1.0, 1.0]` трактуется как разделитель аргументов.
- **Варианты решения:**
  1. Сделать разделение по запятым bracket-aware (пропускать запятые внутри `[...]`)
  2. Для Float3 настроек — собирать следующие 3 позиционных аргумента в `parse_setting_value`, если значение — одно число
  3. Оба варианта вместе
- **Воркэраунд:** `set silhouette_color, [1.0 1.0 1.0]` (пробелы вместо запятых внутри скобок) — нужно проверить
- **Приоритет:** высокий (затрагивает все Float3 настройки: направления света, цвета, bg_rgb)
- **Дата:** 2026-02-18
